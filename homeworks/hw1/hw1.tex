\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{xcolor}

\renewcommand{\arraystretch}{1.5}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\title{Computer Architecture HW1}
\author{Fabian WÃ¼thrich}

\begin{document}

\maketitle

\begin{enumerate}
    \item Critical Paper Reviews (1000 points)

        see \href{https://safari.ethz.ch/review/architecture20/}{here}
    
    \item Main Memory (150 points)

    \begin{enumerate}
        \item The memory access pattern of application A could induce more \textit{row
            buffer misses} whereas application B has more \textit{row buffer hits}. As a
            \textit{row buffer miss} has a higher latency as a \textit{row buffer hit}, 
            a memory request of application A takes longer.

        \item A \textit{row buffer miss} consumes more energy as a \textit{row buffer hit}
            (e.g. precharge of bitlines necessary). As application A has more \textit{row
            buffer misses} it will also use a larger amount of memory energy.

        \item The scheduling algorithm in the memory controller is most likely FR-FCFS. This
            algorithm could prioritize application B (\textit{memory performance hog}) because it has 
            a better row buffer locality degrading the performance of application A.
        
        \item Accessing and refreshing a row in DRAM is actually the same process so this policy prevents
            unnecessary refreshes while still maintaining a retention time of 64ms which is good for
            performance and energy consumption. The downside of this policy is that additional circuitry
            is required to keep track of the last access time.

        \item Application B seems to open many different so the new policy will not refresh these rows
            again. Application A has a good row buffer locality and doesn't open many rows which increases
            refresh energy consumption. It is important to note that the total memory energy consumption of
            application B is still higher because of the many row buffer misses.
    \end{enumerate}

    \item DRAM Refresh - Utilization (150 points)
        \begin{enumerate}
            \item We have 4 channels$\times$2 ranks$\times$8 banks$\times$32K rows = $2^{21}$ rows in total
                and $\frac{1.024s}{64ms} = 2^4$ refreshes per row. Thus, $2^{25}$ refreshes across all 
                four channels.

            \item The command bus of each memory channel is occupied for $2^{23}\cdot5ns$ by refreshes. For a
                time-span of $1.024s$ this gives an utilization of $\frac{2^{23}\cdot5ns}{1.024s}=4.096\%$ 

            \item A refresh uses only the command bus so the data bus utilization is 0.

            \item Each bank issues $2^{15}$ banks $\times$ $2^4$ refreshes/bank = $2^{19}$ refreshes and each
                refresh takes $40ns$. Therefore, we have an utilization of
                $\frac{2^{19}\cdot40ns}{1.024s}=2.048\%$
            
            \item We have $2^5$ rows that are refreshed 16 times, $2^9$ rows get refreshed 8 times and
                the remaining $2^{21} - 2^5 - 2^9$ rows are only 4 times refreshed. Therefore,
                \[ 2^5\cdot16 + 2^9\cdot8 + (2^{21} - 2^5 - 2^9)\cdot4 = 8391040\] refreshes in total.

                Then we get an utilization of $\frac{8391040\cdot5ns}{4*1.024s}=1.0243\%$ over all four 
                command buses.
            
            \item The new distribution still uses only the command bus so the data bus utilization is zero. 

            \item We have 64 banks so we get a bank utilization of $\frac{8391040\cdot40ns}{64\cdot1.024}=
                0.5121\%$

            \item The system has to track three different states so we use 2 bits per row. To track the state
                of all rows we need $2$ bits $\times2^{21}$ rows $=4$ Mbit

            \item When using bloom filters the number of refreshes per interval stays the same but we have
                to add the false-positives to the number of rows which are refreshed in each interval. For
                the $64ms$ interval the bloom filter classifies $2^5$ rows correctly plus 
                $(2^{21}-2^5)\cdot2^{-20}$ false-positives so $n_{64}=2^5 + (2^{21}-2^5)\cdot2^{-20}$ rows are 
                refreshed. With a similar reasoning we get $n_{128}=2^9 + (2^{21}-2^9-2^5)\cdot2^{-8}$ and
                $n_{256} = 2^{21} - n_{64} - n_{128}$. Therefore, we get $16 \cdot n_{64} + 8\cdot n_{128} +
                4\cdot n_{256} = 8423823$ refreshes.

                Similar to (e) we get a command bus utilization of $\frac{8423823\cdot5ns}{4*1.024s}=1.028\%$

                Still no data bus used so zero data bus utilization.

                Similar to (g) we get a bank utilization of $\frac{8423823\cdot40ns}{64\cdot1.024}=
                0.5141\%$
        \end{enumerate}
    \item RowHammer (150 points)
    \item RowHammer Mitigation Mechanisms
    \item VRL: Variable Refresh Latency (150 points)
    \item BONUS: DRAM Refresh - Energy (150 points)
\end{enumerate}

\end{document}

