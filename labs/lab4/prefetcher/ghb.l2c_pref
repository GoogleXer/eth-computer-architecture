#include "cache.h"

#define IT_SIZE 256
#define GHB_SIZE 256

#define NUM_LAST_ENTRIES 3
#define PREFETCH_LOOK_AHEAD 4
#define PREFETCH_DEGREE 4

typedef struct IT_Entry IT_Entry;
typedef struct GHB_Entry GHB_Entry;

struct IT_Entry {
    uint64_t ip;
    GHB_Entry *ghb_ptr;
};

struct GHB_Entry {
    uint64_t addr;
    GHB_Entry *prev;
    GHB_Entry *next;
    IT_Entry *it;
};

IT_Entry it[IT_SIZE];
int it_head_idx;

GHB_Entry ghb[GHB_SIZE];
int ghb_head_idx;

void CACHE::l2c_prefetcher_initialize()
{
    cout << "CPU " << cpu << " L2C GHB prefetcher" << endl;

    it_head_idx = 0;
    ghb_head_idx = 0;
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in)
{
    // process only cache loads
    if (type != LOAD) {
        return metadata_in;
    }

    IT_Entry *it_entry = NULL;

    // use linear search for now
    for(int i = 0; i < IT_SIZE; i++) {
        IT_Entry *curr = it + i;
        if(curr->ip == ip) {
            it_entry = curr;
            break;
        }
    }

    if (it_entry == NULL) {
        // it not in index table -> allocate new IT entry
        it_entry = it + it_head_idx;
        it_entry->ip = ip;
        it_entry->ghb_ptr = NULL;

        it_head_idx = (it_head_idx + 1) % IT_SIZE;
    }

    GHB_Entry *ghb_entry = ghb + ghb_head_idx;

    // invalidate prev of more recent entry
    if (ghb_entry->next) {
        ghb_entry->next->prev = NULL;
    }

    // invalidate IT entry
    if (ghb_entry->it) {
        ghb_entry->it->ghb_ptr = NULL;
    }

    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

    // insert new entry into GHB
    ghb_entry->addr = cl_addr;
    ghb_entry->prev = it_entry->ghb_ptr;
    ghb_entry->it = it_entry;
    it_entry->ghb_ptr = ghb_entry;

    // update pointers of previous entry
    if (ghb_entry->prev) {
        ghb_entry->prev->next = ghb_entry;
        ghb_entry->prev->it = NULL;
    }

    ghb_head_idx = (ghb_head_idx + 1) % GHB_SIZE;

    // find stride
    GHB_Entry last_entries[NUM_LAST_ENTRIES];
    GHB_Entry *curr = ghb_entry;
    int num_entries = 0;
    for(; curr != NULL && num_entries < NUM_LAST_ENTRIES; num_entries++) {
        last_entries[num_entries] = *curr;
        curr = curr->prev;
    }

    if (num_entries == NUM_LAST_ENTRIES) {
        int64_t stride[NUM_LAST_ENTRIES - 1];

        for (int i = 0; i < NUM_LAST_ENTRIES - 1; i++) {
            if (last_entries[i].addr > last_entries[i+1].addr) {
                stride[i] = last_entries[i].addr - last_entries[i+1].addr;
            } else {
                stride[i] = last_entries[i+1].addr - last_entries[i].addr;
                stride[i] *= -1;
            }
        }

        bool stride_detected = false;
        for (int i = 0; i < NUM_LAST_ENTRIES - 1; i++) {
            if (stride[i] == 0) {
                // abort if we see same address twice
                return metadata_in;
            }

            for (int j = i + 1; j < NUM_LAST_ENTRIES - 1; j++) {
                stride_detected = (stride[i] == stride[j]);
            }
        }

        if (stride_detected) {
            //cout << addr << ": ";
            for (int i = 0; i < PREFETCH_DEGREE; i++) {
                uint64_t pf_addr =
                    (cl_addr + (stride[0] * (PREFETCH_LOOK_AHEAD + i)))
                    << LOG2_BLOCK_SIZE;

                //cout << hex << pf_addr << " ";
                // only issue a prefetch if the prefetch address is in the same 4
                // KB page as the current demand access address
                if ((pf_addr >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                    break;

                prefetch_line(ip, addr, pf_addr, FILL_L2, 0);
            }
            //cout << endl;
        }
    }

    return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " L2C GHB prefetcher final stats" << endl;
}

